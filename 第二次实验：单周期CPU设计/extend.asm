#寄存器$n的值初始化为4n
#数据储存器的值初始化为其地址
main:
#R型运算部分（主要）
    add  $4, $2, $3 #$4=8+12=20
    jal  subroutine #开始执行子程序subroutine
    lw   $4, 4($2) #4($2)=12，12内存地址对应数据存储器的第4个储存单元，存储的是其地址值12,则$4=12
    sw   $5, 8($2) # 8($2)=16,$5=20,则内存地址为16（0x10）的单元存储值为20
    sub  $2, $4, $3 # $4 = 12, $3 = 12，则$2 = 12 - 12 = 0
    or   $2, $4, $3 # $2 = 12 & 12 = 12
    and  $2, $4, $3 # $2 = 12 & 12 = 12
    slt  $2, $4, $3 # $4 不小于 $3，所以 $2 = 0
    
#加载指令部分
    
    sw   $20 0($21) #0($21)=84,84地址所对应的储存值为$20=80=0x50=00000000_00000000_00000001_01000000
    lw   $5, 0($21)
    lb   $6, 1($21)    
    lbu  $7, 2($21) 
    lh   $8, 0($21)   
    lhu  $9, 0($21)    

#条件跳转指令部分    
    beq  $3, $3, equ #相当于无条件跳转
equ:
    bne  $3, $4, noteq #$3=12 ,$4=12 ,不跳转
    sw   $2, 0($3) #内存地址为12的单元储存0
noteq:
    bltz $2, negative # $2=0，不小于0，不跳转
    bgez $2, nonnegative # $2=0>=0成立，跳转到nonnegative
negative:
    j    exit #无条件跳转
nonnegative:
    j    exit #无条件跳转
exit:
    j    main #无条件跳回main

#立即数运算部分
subroutine:
    addi $4, $4, 1 #$4 = 20 + 1 = 21
    ori  $4, $4, 0xffff # $4 = 21 | 0xffff = 0x0000_ffff
    jr   $ra #函数调用返回